#!/usr/bin/env bash


# This script transforms an operator dir structured in the style of
# community-operators into one expected by operator-registry, inserts the
# scorecard proxy container, and proxy kubeconfig secret, volume, and mount
# into a CSV, creates CR's from CSV metadata, deploys the operator with the
# OLM in a local cluster, and runs the SDK scorecard against the operator.

set -e

. ./scripts/ci/env

# Create catalog manifests and Dockerfile to create a registry image.
create_catalogsource_file "$CATALOGSOURCE_FILE" "$PKG_NAME" "$OP_REGISTRY_IMAGE" "$NAMESPACE"
create_subscription_file "$SUBSCRIPTION_FILE" "$PKG_NAME" "$PKG_NAME" "$CHANNEL_NAME" "$CSV_NAME" "$NAMESPACE"
if kubectl get operatorgroups --namespace="$NAMESPACE" 2>&1 | grep "No resources found."; then
  create_operator_group_file "$OPERATOR_GROUP_FILE" "$PKG_NAME" "$CSV_FILE" "$NAMESPACE"
fi
create_registry_dockerfile "Dockerfile" "$PKG_NAME"

# Add scorecard proxy resources to the CSV.
create_cr_files_from_metadata "$CSV_FILE" "$CR_DIR" "$NAMESPACE"
create_kubeconfig_secret_file "$SECRET_FILE" "$NAMESPACE"
insert_kubeconfig_volume "$CSV_FILE"
insert_kubeconfig_secret_mount "$CSV_FILE"
insert_proxy_container "$CSV_FILE" "$SC_PROXY_IMAGE"

# Build a registry container containing operator manifests.

if [[ "$REG_IMAGE" ]]; then
  docker build -t "$REG_IMAGE" . > /dev/null
  docker push "$REG_IMAGE" > /dev/null
else
  docker build -t "$OP_REGISTRY_IMAGE" . > /dev/null
fi